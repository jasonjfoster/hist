---
title: "Quote"
author: "[Jason Foster](mailto:jason.j.foster@gmail.com)"
date: last-modified
categories:
  - analysis
  - finance
  - python
draft: true
editor: 
  mode: source
---

```{python}
import os
import time
import requests
import pandas as pd
import contextlib
```

```{python}
data_interval = pd.read_csv("data_interval.csv")
```

```{python}
def check_symbols(symbols):
  
  if isinstance(symbols, str):
    symbols = [symbols]
  
  valid_symbols = (isinstance(symbols, (list, tuple)) and len(symbols) > 0 and
    all(isinstance(s, str) and s.strip() != "" for s in symbols))
    
  if not valid_symbols:
    raise ValueError("invalid 'symbols'")
```

```{python}
def check_date(date, type):
  
  try:
    pd.to_datetime(date, format = "%Y-%m-%d")
  except ValueError:
    raise ValueError(f"invalid '{type}'")
```

```{python}
def check_interval(interval):
  
  valid_interval = set(data_interval["field"])
  
  if interval not in valid_interval:
    raise ValueError("invalid 'interval'")
```

```{python}
def check_intraday(from_date, to_date, interval):
  
  from_date = pd.to_datetime(from_date, format = "%Y-%m-%d")
  to_date = pd.to_datetime(to_date, format = "%Y-%m-%d")
  
  valid_lookback = data_interval.loc[data_interval["field"] == interval, "lookback"].iloc[0]
  
  if (to_date - from_date).days <= 0:
    raise ValueError("value of 'to_date' must be greater than 'from_date'")
  
  if (interval == "1m") and ((to_date - from_date).days > 8):
    raise ValueError("number of days between 'from_date' and 'to_date' must be less than or equal to 8")
  
  if ~pd.isna(valid_lookback) and ((pd.Timestamp.now() - from_date).days > valid_lookback):
    raise ValueError(f"number of days between 'from_date' and today must be less than or equal to {valid_lookback}")
```

```{python}
def process_date(date):
  
  result = int(pd.to_datetime(date, utc = True).timestamp())
  
  return result
```

```{python}
# def process_url(params):
# 
#   result = "?" + "&".join(f"{key}={value}" for key, value in params.items())
# 
#   return result
```

```{python}
@contextlib.contextmanager
def with_(new_env):
  
  old_env = {}

  try:

    for name, value in new_env.items():

      old_env[name] = os.environ.get(name)

      if value is None:
        os.environ.pop(name, None)
      else:
        os.environ[name] = value

    yield

  finally:
    
    for name, value in old_env.items():
      
      if value is None:
        os.environ.pop(name, None)
      else:
        os.environ[name] = value
```

```{python}
def get_session():
  
  session = requests.Session()
    
  api_url = "https://query1.finance.yahoo.com/v1/test/getcrumb"
  
  headers = {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36",
  }
  
  session.headers.update(headers)

  with with_({"CURL_SSL_BACKEND": "openssl"}):
    response = session.get(api_url)
  
  crumb = response.text.strip()
  cookies = session.cookies.get_dict()

  result = {
    "handle": session,
    "crumb": crumb,
    "cookies": cookies
  }
  
  return result
```

```{python}
def get_data(symbols, from_date = "2007-01-01", to_date = None, interval = "1d"):
  
  if isinstance(symbols, str):
    symbols = [symbols]
  
  if to_date is None:
    to_date = pd.Timestamp.now()
    
  check_symbols(symbols)
  check_date(from_date, "from_date")
  check_date(to_date, "to_date")
  check_interval(interval)
  check_intraday(from_date, to_date, interval)
  
  session = get_session()
  cookies = session["cookies"]
  handle = session["handle"]
  
  params = {
    "period1": process_date(from_date),
    "period2": process_date(to_date),
    "interval": interval
  }
  
  headers = {
    "Content-Type": "application/json",
  }
  
  for key, value in cookies.items():
    handle.cookies.set(key, value)
  
  count = 0
  cols = ["index", "open", "high", "low", "close", "adjclose", "volume"]
  intraday = data_interval.loc[data_interval["field"] == interval, "intraday"].iloc[0]
  # result_ls = []
  result_ls = {}

  for symbol in symbols:
    
    api_url = "https://query1.finance.yahoo.com/v8/finance/chart/" + symbol # + process_url(params)
      
    try:
      
      response = handle.get(api_url, params = params, headers = headers)
            
      result = response.json()
      result_df = result["chart"]["result"][0]

    except:
      result_df = pd.DataFrame()

    if (len(result_df) > 0):
      
      tz = result_df["meta"]["exchangeTimezoneName"]
      ohlcv = result_df["indicators"]["quote"][0]
      adjclose = result_df["indicators"]["adjclose"][0]["adjclose"]
      index = result_df["timestamp"]
      
      if not intraday:
        index = pd.to_datetime(index, unit = "s", utc = True).tz_convert(tz).date
      else:
        index = pd.to_datetime(index, unit = "s", utc = True).tz_convert(tz)

      result_df = pd.DataFrame({
        "index": index,
        **ohlcv,
        "adjclose": adjclose
      })
      
      result_df = result_df[cols]
      # result_ls.append(result_df)
      result_ls[symbol] = result_df

    count += 1

    if count % 5 == 0:

      print("pause one second after five requests")
      time.sleep(1)

  # if not result_ls:
  #   return pd.DataFrame()

  return result_ls
```

```{python}
from_date = "2007-01-01"
to_date = pd.Timestamp.now()
interval = "1d"
symbols = ["BLK", "BX", "BAICX"]
symbol = symbols[0]
```

```{python}
prices_ls = get_data(symbols)
```